# 什么是操作系统
操作系统是位于计算机用户和硬件资源中间的一层软件系统，目的是可以对 **硬件进行管理和抽象**，为用户提供服务。提供一个Runtime Environment，与**设备无关**的运行环境。
为用户程序提供硬件资源的抽象abstraction
管理和分配计算机硬件资源。运行同时运行程序、共享内存、共享设备
## 操作系统中的抽象
抽象可以给上层提供更方便的访问机制，同时抽象可以对内部细节进行保护。
1、 Thread：一个指令序列，好像拥有了整个机器
2、Address Space：一个私有的、连续的好像无穷大的寻址范围。
3、File：一段持久化存储的信息，可以按照文件名进行读写
4、IO Device：一个可以读写控制的对象
## 如何实现保护
为了让多个程序同时运行，需要确保一个程序的bugs或者恶意行为不会对整个系统造成影响，此时需要操作系统进行保护
* 用户无法和硬件直接接触
* 用户进程无法访问内核资源
* 用户程序不应该对操作系统或者其他程序产生影响
为了保证操作系统的绝对地位：
* 拥有特权级指令。因而区分了内核态和用户态。
* 对用户地址空间进行划分，可以支持共享和保护。
## 中断 Interrupt
一种打断CPU正常工作的机制。
可以包括IO中断、系统调用和异常、时钟中断
系统可以配置一个IDT核和一个记录IDT起始位置的寄存器来找到所有的中断处理程序的入口。中断处理程序的参数位置需要操作系统设计者进行规定。
中断发生之后是否由硬件来保存某些参数是由ISA规定的。对于x86，硬件会负责保持PC\SP\一些状态位到Kernel Stack以保证安全，其余的寄存器由中断处理程序进行保存。恢复的时候，中断处理程序会先恢复寄存器信息，然后iret指令会负责恢复PC\SP和PSW
**当处理中断的时候又发生了一次中断怎么办？**
* 关闭中断，其余中断信息暂时被屏蔽
* 分为top-half和bottom-half。前者关闭中断保存一些必要的状态信息并且将任务放到一个队列里，后者开启中断处理剩下的事务。
## 操作系统的启动过程
CPU Reset之后从一个规定的位置开始执行代码。 BIOS程序找到可引导设备，将第一个512Bytes加载到内存中，然后设置0x7c00位置开始执行，然后加载更多的代码到内存中，然后找到操作系统的main函数？
## 操作系统的架构
### 宏内核
所有模块运行在内核态，使用模块化（可以加载卸载服务）、抽象（Everything is a FILE）和分层（User mode \ Kernel mode）控制复杂度。
内核中有一个地方出问题会影响整个系统的稳定性；不需要频繁的进行内核态和用户态的切换
### 微内核
只保留最核心的功能在内核部分，其余的功能在用户态实现。稳定性好但是效率低。

# 进程与线程

## 程序 VS 进程

程序可以视作是状态机的静态描述，描述了所有可能的程序状态。程序动态起来就成为了一个进程。操作系统对正在运行的程序的一个抽象。
进程定义了操作系统进行资源分配和管理的粒度，刻画了并发执行和提供调度的粒度（当然更准确来说应该是线程）
<img src=".\images\1.png" alt="1" />
状态机的状态可以通过PCB来刻画。

**操作系统=状态机的管理者**
**在Windows里面**
*创建 spawn*
*销毁 _exit()* 
**在UNIX里面**
*创建fork()*
*复位状态机execve()*

**fork**
立即复制一个状态机，部分状态。例如寄存器状态，打开文件列表。但是pid这个属性没有被复制。

假如创建出来的子进程的父亲进程被销毁了，那么该进程成为“孤儿进程”，在UNIX中会被1号进程托管。但是也有可能会被user的systemd托管。
父子进程会得到相同但是分离的地址空间。
并发执行。


**execve**
复位一个状态机，回到最初的起点。复位只复位了程序可见的部分状态，操作系统内部的状态并没有被复位，比如ppid。
execve是执行一个程序的唯一的系统调用。我们可以发现UNIX Shell中打开任意一个程序，用strace去观察，第一个执行的总是execve(filename, argv, envp)。
execve中没有argc，所以最后一个参数必须是NULL
## 进程的终止
本身没有结束自己的能力，需要系统调用SYS_exit，库函数exit对其进行了封装。
**僵尸进程**指的是那些已经结束执行但是PCB还没被回收的进程。
## 进程的生命周期
<img src=".\images\2.png" alt="1">
重点：进程的七状态模型
<img src=".\images\3.png" alt="1">
suspend的引入使得在有限的内存空间里面可以执行多个进程，一些不需要的进程可以暂时被交换到磁盘的swap分区，某种程度上相当于拓展了内存的有效空间。
### 上下文切换
Coontext可以视作是程序的一些状态的描述，包括寄存器状态。btw，由于操作系统会对地址空间进行隔离，所以一般切换上下文的时候不会对内存的值造成影响。
Context可以保留到Kernel Stack或者指定的一个安全的位置，这个切换的程序一般是一段汇编代码。
<img src=".\images\4.png" alt="1">

## 进程的地址空间

进程的地址空间是划分为一个段一个段的，每个段都有各自的权限。如果想知道有什么段可以问问GPT捏。

如何修改一个进程的地址空间？使用 **mmap**系统调用。 

mmap可以申请一片内存空间，还可以进行文件映射。

我们可以使用pmap来查看一个进程的地址空间。对于Linux操作系统，实际上是访问了/proc/pid/目录下的信息
**Everything is a FILE**
在UNIX操作系统中，映射一个大文件十分迅速，我们只访问其中的一小部分。
## 线程
为了将资源分配管理和执行序列分开，我们引入了线程。
<img src=".\images\5.png" alt="1">
<img src=".\images\6.png" alt="1">
为什么需要线程？更方便资源共享。创建、销毁和切换的开销代价比较小。
### User-Level Thread
由用户态，也就是进程自己管理线程，操作系统不可知。
pros：
* 开销小
* 自定义调度策略
* 方便移植
cons:
* 只有一个CPU可以执行
* 一个线程阻塞其余也阻塞
* 只有一个线程yield之后其余线程才能获取运行权
### Kernel-Level Thread
内核负责线程的调度
# 进程/线程调度
## 理解几个调度目标
burst time：total time taken by the processor for its execution on CPU (excluding wating for IO)
arrival time: 进程进入ready状态
response time: 从就绪到第一次获取响应的时间
- Batch System
-- 吞吐量：单位时间执行的进程数
-- 周转时间：从创建到完成，创建之后不一定被马上执行，中途也可能终止运行。
- 交互式习系统
-- 响应时间：从创建到第一次获得相应，比如鼠标的移动、键盘的输入
-- 等待时间：等待CPU的时间
## 几种常见的调度策略
针对批处理系统：
1、 First Come First-Served 先到先服务
如果是长任务先到达，会显著推迟后续短任务的执行。平均周转和响应时间会增加。当该任务需要等待IO的时候，会一直阻塞CPU。
2、 短作业优先
优先调度运行时间短的，所有任务同时到达会有最后平均周转时间（贪心算法），会导致饿死现象**，因为对某种任务有偏好，在这里是短任务**
3、剩余最短时间优先
抢占式，每当发生进程进入/调度的时候就要重新计算剩余时间，优先选择最短任务进行执行。和SJF一样可以优化周转时间，但都会有饿死现象。
针对交互式系统的调度算法：
1、 时间片轮转
利用时钟中断进行切换，如果任务提前结束了也可以进行切换。不会优先什么任务，不会导致饿死。但是进程切换开销大，频繁的切换，所以需要精心设计时间片长度。如果任务同时到达，该算法会导致比较高的周转时间，因为任务被切分成多个时间片运行了。
2、优先级调度
给每个进程不同的优先级，不同优先级队列可以使用不同的调度算法。
3、多级反馈队列
多个优先级队列，时间片用完到下一个优先级。会导致长任务大概率到最后的优先级，可能会导致饿死现象。
* 队列个数
* 初始优先级设置
* 每个队列的时间片长度，不同的调度算法
真实世界的调度算法
CFS：Completely Fair Scheduler
设定一个调度周期，在这个周期内所有任务都会被雨露均沾。time slice = sched_latency / #task
但是随着任务数量增加，时间片会太短，系统会有一个保证的最小时间，保证time slice比较合理。
使用加权的方法来确定每个进程的使用时间（nice值被映射到一个权重值）
<img src=".\images\7.png" alt=1>



# 虚拟内存
地址空间是进程所能看到的一片连续的地址范围。进程看到的是虚拟的、大容量的、连续的私有的地址空间。对于硬件来说，真实的内存是一个有限的、被多个进程共享的地址空间。
在Linux系统中，每个任务有一个mm_struct结构，将一个地址空间划分为多个连续的area片段。
为了实现虚拟内存，必要的任务是进行地址转换，将一个虚拟地址转换为实际的物理地址。
利用地址转换可以实现**动态重定位**，在运行过程中将进程加载到不同的物理地址。
还可以实现**地址隔离保护**，不同进程映射到不同的地址空间，而且不能相互访问。
可以实现**内存共享**，只要将某个地址段映射到同一块内存空间即可。
还可以创建**拥有无限地址空间的假象**，只需要将不同地址在不同时间映射到同一块区域即可？
## 连续内存空间管理
1、使用Base and Bound两个寄存器来划分每一个进程的地址空间，切换上下文只需要改变这两个寄存器的value。
管理方式：①bitmap，将内存划分为多个相同的小单元②Linked List
两种碎片：①外部碎片：分块之间的空间太小太零碎无法利用②内部碎片：分区内未利用的
动态内存分配问题：如果从最适合的位置分配可能会产生更多的外部碎片，所以从最大的位置分配。只要是动态内存分配都或多或少会导致一些外部碎片。
malloc并不一定就是在Heap上分配，对于小容量高频分配会在heap上使用brk()，对于低频大容量使用mmap分配。
2、分段 Segmentation
将进程的地址空间视作一组分离的段，每个段可以有自己的base and bound。
**地址共享**：不同进程的拥有相同的段表即可。
由于段的大小不一致，所以会导致动态内存分配问题
<img src=".\images\8.png" alt=1>
3、分页 Paging
将内存分为多片相同大小的页（4K、64K等等），建立虚存到实际内存的一个映射即可，没有外部碎片问题。
<img src=".\images\9.png" alt=1>
PTE通常会包括物理页框号、存储控制信息，按照bytes or words对齐。
分页模式下的几个机制：
**内存共享**：多个进程同时映射到一片内存区域即可
**写时复制**：只要能共享就一直共享，直到某个区域发生了修改才进行复制（成为该进程独有的）
## 线性页表的问题
### Too Big
由于我们需要记录每一个页项的映射关系，最终的PTE数量就会比较大，占用很多的内存空间。如果单纯的增加页的大小又会导致内部碎片问题突出。
使用多级页表，将连续的PTE进行分页存储。
<img src=".\images\10.png" alt=1>
### Too Slow
地址转换的开销比较大，特别是涉及多级页表的情况。我们借鉴Cache的思路，将页表项进行缓存。这是通过CPU中的MMU中的TLB实现的。TLB hit的时候直接访问，miss的时候更新到TLB中。
## 请求调页机制
为了让单个程序的虚拟内存空间可以超出实际物理内存空间，可以将一部分暂时不需要的页放到磁盘中，需要的时候才调度进来。
如果访问的时候，该页不在物理内存中，会发生Page Fault异常，然后陷入到内核中进行调度。
<img src=".\images\11.png" alt=1>
如果内存中没有空闲也框了，则会选取一定的替换策略，挑选一个页框替换下去，修改PTE相关设置，检查内容是否被改变，如果发生了改变会写回磁盘。
## 替换策略
1、FIFO，替换最先进来的，但是会有Belady现象，增加页框个数反而带来更高的Page Fault Rate
2、LRU，替换最近未使用，维护成本高！
3、优化后的LRU，只看最近一个时钟周期，Second Chance
### Thrashing机制
如果一个进程分配到太少的页框，则无论选用什么策略，都会导致比较高的Page Fault Rate。此时可以kill掉一些进程，但是调度器又会swap in更多进程，最终表现为**低CPU利用率、高IO率**
# 同步
## 条件变量

## 如何正确地访问临界区
使用的时候保证互斥，但是实现互斥的test和set代码不是原子性的。
一个例子
```C
flag = 0;
void lock() {
	while (flag == 1);
	flag = 1;
}
void unlock() {
	flag = 0;
}
```
以上代码存在一个问题，当flag = 0时，进程A会进入到flag = 1这一行，但还没执行。此时B也进入了这一段代码，设置flag = 1。这时候临界区有两个进程。
## Peterson算法
纯软件的方式，适用于两个进程的互斥。严格轮转的。
flag[2]表示当前我是否想进入临界区，turn表示轮到谁进入。
```C
T1
void T1() {
	while (1) {
		flag[0] = true;
		turn = 1;
		while (flag[1] && turn == 1);
		# Critical Session
		flag[0] = false;
		# Remainder
	}
}
```

缺点：①只适用于两个进程②会有busy-wating浪费资源③依赖于指令的顺序和原子性，但是现代处理器会有指令重排，可能导致算法失效。
# 文件和设备

## 文件描述符

指向操作系统对象的指针。在UNIX设计哲学中，Everything is a FILE。通过指针可以访问“一切”。

操作系统总是分配最小的未使用描述符。

新打开的文件总是从3号文件符开始打开。

**文件描述符是进程状态的一部分**使用fork创建新的进程的时候， 文件描述符会被继承。

任何可以读写的东西都是一个文件

* 真实的设备文件
* 虚拟的文件

## 管道pipe

管道有一个文件读口和一个文件写口。创建的时候返回两个文件描述符。一般用于进程间通信，Inter-Process Communication

一个有趣的例子：假如我们fork创建了一个新的进程。我们可以利用pipe机制实现进程间的通信。UNIX shell中的 | 也是基于这样的实现。

创建管道的两个方法

* pipe创建匿名管道
* mkfifo创建实际管道（有一个文件）

## 反思

对于一个流式的数据，使用文件描述符挺好的。但是对于有结构的字节序列数据，使用mmap可能更加方便。

# 可执行文件

elf是一个人类不太友好的文件格式。使用elfcat来生成一个可视化的html文件。

elf文件可以看作是对程序状态机的初始状态的静态描述。 

elf文件就是一个“数据结构”。我们的binutils无非就是将这个数据结构的部分内容解释出来了。

# 构建真实可用的操作系统世界

Linux程序启动后会执行第一个程序，init。然后系统会执行initramfs，来创建一个在RAM中的文件系统。该文件系统包括了/ /bin /dev/console等等目录。

接着会创建busybox中的一些文件的别名

然后系统通过一系列的syscall来逐步构建我们真实可用的操作系统。其中关键的一个系统调用时switch_root，将磁盘中的文件系统叠加到RAM中去。		
# SIMD与SIMT
## SIMD
随着小核的频率无法再提高，Intel开始横向拓展多核心CPU。为了进一步提高整体的能耗比，开始区分大小核。
在指令集设计方面，为了迎合多媒体的应用场景，开始出现SIMD指令集，支持同时对多个数据单元进行同样的数据操作。 
## SIMT
对多个“位置”采取同样的一个操作。我们可以直接开启很多的线程来并行这个操作。
多个处理核心可以有自己的regs，ALU，但是PC是可以共享的。也就是同步同一条指令，但是regs的值可以不一样。